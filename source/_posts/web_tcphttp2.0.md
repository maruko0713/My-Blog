
---
title: HTTP2.0新知&&TCP/IP拾遗
date: 2016-10-02
tags: ["HTTP"]
---

## 前言
最近看了一下HTTP2.0，借着学这个的机会，把两年前学的TCP/IP拾起来。     
    
## TCP/IP拾遗
TCP/IP协议是一个协议集合，HTTP协议其实是TCP/IP协议家族中的一员。   


### IP协议
IP协议属于网络层。    
IP协议的作用在于把各种数据包准确无误的传递给对方，其中两个重要的条件是IP地址，和MAC地址（Media Access Control Address）。   
通常的IP地址是路由器给我们生成的IP地址，路由器里面会记录我们的MAC地址。而MAC地址是全球唯一的，除去人为因素外不可能重复。MAC地址是网卡决定的，是固定的。
   
### TCP协议
按层次分，TCP属于传输层，提供可靠的字节流服务。
如果说IP协议是找到对方的详细地址。那么TCP协议就是把安全的把东西带给对方。各有分工，互不冲突。       
所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。一言以蔽之，TCP 协议为了更容易传送大数据才把数据分割，而且 TCP 协议能够确认数据最终是否送达到对方。     
  
TCP/IP协议族中有一个重要的概念是分层，TCP/IP协议按照层次分为以下四层：    
- 应用层
- 传输层
- 网络层
- 数据链路层 
### 数据链路层
用来处理连接网络的硬件部分。
包括控制操作系统，硬件的设备驱动，网卡，以及光纤等物理可见部分。    
硬件上的范畴均在数据链路层的作用范围之内。   
   
### 网络层
网络层用来处理在网络上流动的数据包。    
数据包是网络传输的最小数据单位。   
该层规定了通过怎样的路径（传输路线）到达对方计算机，并把数据包传输给对方。   
   
### 传输层
传输层提供处于网络连接中的两台计算机之间的数据传输，在传输层有两个不同的协议，TCP 和 UDP 协议。

TCP（传输控制协议）
UDP（用户数据报协议）  

>传输控制协议TCP是一个面向链接的、可靠的通信协议。
 
 1. 在开始传输前，需要进行三次握手建立链接
 2. 可靠性：在传输过程中，通信双方的协议模块继续进行通信
 3. 通信结束后，通信双方都会使用改进的三次握手来关闭链接 
   
>UDP为应用程序提供的是一种不可靠的、无连接的分组交付，因此，UDP报文可能会出现丢失、乱序、重复、延时等问题。
   
### 应用层
应用层决定了向用户提供应用服务时通信的活动（规定传输的数据格式）。

FTP（文件传输协议）   
DNS（域名系统）    
HTTP协议（超文本传输协议）  

## HTTP2.0
### 二进制协议
HTTP/1.1 版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。
 
### 多工
HTTP/2 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

### 数据流
因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。

### 头信息压缩
HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。    
   
### 服务器推送
HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

